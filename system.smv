
------------------------------------- Bus ------------------------------------
MODULE Bus
VAR
  AD:      {0,1}; -- address
  DT:      boolean; -- data if CTRL is write
  CTRL:    {read, write};
  arb_gnt: {l1_1, mem}; -- arbitre decision
  valid:   boolean; -- data on the bus is valid

----------------------------------- Memory -----------------------------------
MODULE Memory(bus)
VAR
  data: array 0..1 of boolean; -- internal data
  AD:    {0,1}; -- requested adress
  DT:    boolean; -- response to bus
  valid: boolean; -- if data is valid

ASSIGN
  init(data[0]) := FALSE;
  init(data[1]) := FALSE;
  init(AD)      := 0;
  init(DT)      := FALSE;
  init(valid)   := FALSE;

  next(DT) :=
    case
      bus.valid & bus.CTRL = read: data[bus.AD];
      TRUE: DT;
    esac;
  next(valid) :=
    case
      bus.arb_gnt = mem & bus.DT = DT: TRUE; -- if bus out data is mem data, then valid is TRUE
      TRUE:                            FALSE; -- else valid is false
    esac;

------------------------------------ Cache -----------------------------------
MODULE Cache(bus, processor)
VAR
  AD:   {0,1}; -- address
  DT:   boolean; -- data if CTRL is write
  CTRL: {read, write};
  valid:boolean; -- if data is valid
  req:  boolean; -- cache request for bus

ASSIGN
  init(AD)   := 0;
  init(DT)   := FALSE;
  init(CTRL) := read;
  init(valid):= FALSE;
  init(req)  := TRUE;
  next(req) :=
    case
      req = TRUE & bus.arb_gnt = mem & bus.valid = TRUE: req = FALSE;
      TRUE:                                        TRUE; -- request infinitely often for now
    esac;


---------------------------------- Processor ---------------------------------
MODULE Processor
VAR
  req:   {idle, load, store}; -- processor request
  AD:    {0,1}; -- requested adress
  DT:    boolean; -- data from l1
  valid: boolean; -- if data is valid

ASSIGN
  init(req)   := idle;
  init(AD)    := 0;
  init(DT)    := FALSE;
  init(valid) := FALSE;


------------------------------------ Main ------------------------------------
MODULE main
VAR
  bus: Bus;
  processor: Processor;
  cache: Cache(bus, proc);
  memory: Memory(bus);

ASSIGN
  ----- init values ----------
  init(bus.arb_gnt) := l1_1;

  -- bus arbitre --
  next(bus.arb_gnt) :=
    case
      bus.arb_gnt = mem & cache.req & bus.valid = TRUE: l1_1; -- if mem data is valid on the bus, then next master is l1_1
      bus.arb_gnt != mem:                               mem; -- if bus master is not mem, then next is mem
      TRUE:                                             mem; -- default bus master is mem
    esac;

  -- bus out --
  bus.AD :=
    case
      bus.arb_gnt = l1_1: cache.AD;
      TRUE: memory.AD;
    esac;
  bus.DT :=
    case
      bus.arb_gnt = l1_1: cache.DT;
      TRUE: memory.DT;
    esac;
  bus.CTRL :=
    case
      bus.arb_gnt = l1_1: cache.CTRL;
      TRUE: read;
    esac;
  bus.valid :=
    case
      bus.arb_gnt = l1_1: cache.valid;
      TRUE: memory.valid;
    esac;


--------------------------- Specifications ---------------------------
SPEC AG AF(bus.arb_gnt = mem) -- mem is always infinitely often the master
SPEC AG AF(bus.arb_gnt = l1_1) -- l1_1 is infinitely often the master
SPEC AX (bus.AD = memory.AD) -- not that important
SPEC AX (bus.DT = memory.DT) -- not that important
SPEC AX (bus.valid = memory.valid) -- not that important
SPEC AG (bus.valid & bus.arb_gnt = l1_1) -> (bus.AD = cache.AD & bus.DT = cache.DT & bus.CTRL = cache.CTRL) -- if l1_1 is bus master, then bus out must be l1_in
