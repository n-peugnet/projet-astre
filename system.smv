
------------------------------------- Bus ------------------------------------
MODULE Bus
VAR
  ------------- Real Bus data --------------
  AD:      {0,1}; -- address
  DT:      boolean; -- data if CTRL is write
  CTRL:    {read, write};
  arb_gnt: {none, l1_1, mem}; -- arbitre decision
  valid:   boolean; -- data on the bus is valid

  ------------- Computed state -------------
  is_valid_mem:  boolean;
  is_valid_cache: boolean;

ASSIGN
  is_valid_mem := arb_gnt = mem & valid;
  is_valid_cache := arb_gnt = l1_1 & valid;

----------------------------------- Memory -----------------------------------
MODULE Memory(bus)
VAR
  data: array 0..1 of boolean; -- internal data
  AD:    {0,1}; -- requested adress
  DT:    boolean; -- response to bus
  CTRL:  {read, write};
  valid: boolean; -- if data is valid

ASSIGN
  init(data[0]) := FALSE;
  init(data[1]) := TRUE;
  init(AD)      := 0;
  init(DT)      := FALSE;
  init(CTRL)    := read;
  init(valid)   := FALSE;

  ---------- internal values ---------
  next(data[0]) :=
    case
      bus.is_valid_cache & bus.CTRL = write & bus.AD = 0: bus.DT;
      TRUE:                                               data[0];
    esac;
  next(data[1]) :=
    case
      bus.is_valid_cache & bus.CTRL = write & bus.AD = 1: bus.DT;
      TRUE:                                               data[1];
    esac;
  ------------ bus values ------------
  next(AD) :=
    case
      bus.valid: bus.AD;
      TRUE: AD;
    esac;
  next(DT) :=
    case
      bus.valid & bus.CTRL = read: data[bus.AD];
      TRUE: DT;
    esac;
  next(CTRL) :=
    case
      bus.valid: bus.CTRL;
      TRUE: CTRL;
    esac;
  next(valid) :=
    case
      bus.arb_gnt = mem & bus.DT = DT: TRUE; -- if bus out data is mem data, then valid is TRUE
      TRUE:                            FALSE; -- else valid is false
    esac;

------------------------------------ Cache -----------------------------------
MODULE Cache(bus, processor, id)
VAR
  ---------- internal values ---------
  AD:   {0,1}; -- address
  DT:   boolean; -- data if CTRL is write
  CTRL: {read, write};
  valid:boolean; -- if data is valid
  req:  boolean; -- cache request for bus

  ------------- Computed state -------------
  is_our_request: boolean;
  is_our_response: boolean;

ASSIGN
  is_our_request := bus.AD = AD & bus.CTRL = CTRL;
  is_our_response := req = TRUE & bus.is_valid_mem & is_our_request;

  init(DT)   := FALSE;
  init(CTRL) := read;
  init(req)  := TRUE;

  AD := processor.AD;
  processor.DT := DT;
  next(DT) :=
    case
      processor.req = load & is_our_response: bus.DT;
      processor.req = store: processor.REG;
      TRUE: DT;
    esac;
  next(CTRL) :=
    case
      processor.req = load: read;
      processor.req = store: write;
      TRUE: CTRL;
    esac;
  next(req) :=
    case
      is_our_response :      FALSE;
      processor.req != idle: TRUE;
      TRUE:                  req;
    esac;
  next(processor.valid) :=
    case
      is_our_response : TRUE;
      TRUE:             FALSE; -- default is not valid
    esac;

  valid := bus.arb_gnt = id & req;


---------------------------------- Processor ---------------------------------
MODULE Processor
VAR
  req:   {idle, load, store}; -- processor request
  AD:    {0,1}; -- requested address
  REG:   boolean; -- proc data
  DT:    boolean; -- data from l1
  valid: boolean; -- if data is valid

ASSIGN
  init(req)   := load;
  init(AD)    := 0;
  init(REG)   := FALSE;
  init(valid) := FALSE;

  next(req) :=
    case
      valid: {idle, load, store};
      TRUE: req;
    esac;
  next(AD) :=
    case
      valid: {0,1};
      TRUE: AD;
    esac;
  next(REG) :=
    case
      valid: {TRUE,FALSE};
      TRUE: REG;
    esac;

------------------------------------ Main ------------------------------------
MODULE main
VAR
  bus: Bus;
  processor: Processor;
  cache: Cache(bus, processor, l1_1);
  memory: Memory(bus);

ASSIGN
  ----- init values ----------
  init(bus.arb_gnt) := none;

  -- bus arbitre --
  next(bus.arb_gnt) :=
    case
      cache.req & (bus.is_valid_mem | bus.arb_gnt = none) : l1_1; -- if mem data is valid on the bus, then next master is l1_1
      bus.is_valid_cache | bus.arb_gnt = mem:               mem; -- if cache made a request, then next master is mem
      TRUE:                                                 none; -- default bus master is none
    esac;

  -- bus out --
  bus.AD :=
    case
      bus.arb_gnt = l1_1: cache.AD;
      TRUE: memory.AD;
    esac;
  bus.DT :=
    case
      bus.arb_gnt = l1_1: cache.DT;
      TRUE: memory.DT;
    esac;
  bus.CTRL :=
    case
      bus.arb_gnt = l1_1: cache.CTRL;
      TRUE: memory.CTRL;
    esac;
  bus.valid :=
    case
      bus.arb_gnt = l1_1: cache.valid;
      TRUE: memory.valid;
    esac;

  -------------- temporary test changes --------------
  -- next(processor.AD) :=
  --   case
  --     processor.valid & processor.AD = 1: 0; -- alternate between 2 addresses for now
  --     processor.valid & processor.AD = 0: 1;
  --     TRUE: processor.AD;
  --   esac;
  -- next(processor.REG) :=
  --   case
  --     processor.valid & processor.AD = 1 & processor.REG = TRUE: FALSE; -- alternate between datas for now
  --     processor.valid & processor.AD = 1 & processor.REG = FALSE: TRUE;
  --     TRUE: processor.REG;
  --   esac;
  -- next(processor.req) :=
  --   case
  --     processor.valid & processor.AD = 1 & processor.REG = TRUE & processor.req = load: store; -- alternate between load and store for now
  --     processor.valid & processor.AD = 1 & processor.REG = TRUE & processor.req = store: load;
  --     TRUE: processor.req;
  --   esac;


--------------------------- Specifications ---------------------------
-- SPEC AG AF(bus.arb_gnt = mem) -- mem is always infinitely often the master
-- SPEC AG AF(bus.arb_gnt = l1_1) -- l1_1 is infinitely often the master

-- if l1_1 is bus master, then bus out must be l1_in --
SPEC AG ( (bus.arb_gnt = l1_1) -> (bus.AD = cache.AD & bus.DT = cache.DT & bus.CTRL = cache.CTRL & bus.valid = cache.valid) )
SPEC AG ( (bus.arb_gnt = l1_1) -> (bus.AD != cache.AD & bus.DT = cache.DT & bus.CTRL = cache.CTRL & bus.valid = cache.valid) )

-- if mem is bus master, then bus out must be mem_in --
SPEC AG ( (bus.arb_gnt = mem) -> (bus.AD = memory.AD & bus.DT = memory.DT & bus.valid = memory.valid) )

-- if l1_1 reads data, then next value in bus is the requested value --
SPEC AG ( (bus.valid & bus.arb_gnt = l1_1 & bus.CTRL = read) -> AX AX (bus.DT = memory.data[cache.AD] & memory.valid) )
-- SPEC AG AF(bus.valid & bus.arb_gnt = l1_1 & bus.CTRL = read)

-- if l1_1 writes data, then next value in memory is the written value --
SPEC AG ( (bus.valid & bus.arb_gnt = l1_1 & bus.CTRL = write) -> AX AX (memory.data[cache.AD] = cache.DT & memory.valid) )
-- SPEC AG AF(bus.valid & bus.arb_gnt = l1_1 & bus.CTRL = write)

-- if proc read a data, the the read value must be the same as the one in memory --
SPEC AG ( (processor.valid & processor.req = load) -> (processor.DT = memory.data[processor.AD]) )
-- SPEC AG AF(processor.valid)

SPEC AG ( (processor.valid & processor.req = store) -> (processor.REG = memory.data[processor.AD]) )

-- verify that the alternance is working (for now) --
-- SPEC AG AF(memory.data[0] = TRUE)
-- SPEC AG AF(memory.data[0] = FALSE)
-- SPEC AG AF(memory.data[1] = TRUE)
-- SPEC AG AF(memory.data[1] = FALSE)

-- SPEC AG AF(cache.AD = 0 & cache.CTRL = read)
-- SPEC AG AF(cache.AD = 1 & cache.CTRL = read)
-- SPEC AG AF(cache.AD = 0 & cache.CTRL = write)
-- SPEC AG AF(cache.AD = 1 & cache.CTRL = write)
-- SPEC AG AF(cache.is_our_response)
-- SPEC AG AF(processor.AD = 0 & processor.req = load & processor.REG = TRUE)
-- SPEC AG AF(processor.AD = 1 & processor.req = load & processor.REG = TRUE)
-- SPEC AG AF(processor.AD = 0 & processor.req = store & processor.REG = TRUE)
-- SPEC AG AF(processor.AD = 1 & processor.req = store & processor.REG = TRUE)
-- SPEC AG AF(processor.AD = 0 & processor.req = load & processor.REG = FALSE)
-- SPEC AG AF(processor.AD = 1 & processor.req = load & processor.REG = FALSE)
-- SPEC AG AF(processor.AD = 0 & processor.req = store & processor.REG = FALSE)
-- SPEC AG AF(processor.AD = 1 & processor.req = store & processor.REG = FALSE)

